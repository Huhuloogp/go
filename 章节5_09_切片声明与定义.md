！！

1、切片只声明时为nil,没有开辟内存空间,不能直接操作切片,需要先初始化

这和声明指针类型变量差不多，声明指针类型变量不能直接使用，需要先初始化一个地址值给它

可以使用make函数定义无内容,但是不是nil的切片,意味着切片已经申请了内存空间

2、转义字符%p是内存地址

3、切片:具有可变长度相同类型元素序列，，切片和数组声明时语法最主要的区别就是长度







# 一.切片

* 切片的英文名称slice
* 切片:具有可变长度相同类型元素序列.
* 由于长度是可变,可以解决数组长度在数据个数不确定情况下浪费内存的问题.
* 切片和数组声明时语法最主要的区别就是长度
```go
	var slice []string  //切片
	var array [3]string //数组
```

* 切片只声明时为nil,没有开辟内存空间,不能直接操作切片,需要先初始化
  * 注意:切片只能和nil进行判断是否相等
```go
	var slice []string  //切片
	fmt.Println(slice==nil)//输出:true
	fmt.Printf("%p",slice)//输出:0x0
```
# 二.定义切片

* 通过直接指定初始值定初始化一个切片变量
```go
	names := []string{"smallming", "佳明哥"}
	fmt.Println(names)
```
* 定义完切片后就可以通过`切片对象[脚标]`取出或修改切片中元素内容.语法和数组相同

# 三.切片是引用类型

* 引用类型在变量之间赋值时传递的是地址.引用类型变量就是这个类型的指针.切片就是引用类型
* 值类型在变量之间赋值时传递的是值的副本
```go
	names := []string{"smallming", "佳明哥"}
	names1 := names
	names1[0] = "张"
	fmt.Println(names, names1)//输出:[张 佳明哥] [张 佳明哥]
	fmt.Printf("%p %p",names,names1)//地址相同
```
