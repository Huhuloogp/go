！！

1、每次对变量重新赋值就是在修改变量地址中的内容	，获取变量也就是获取变量地址

2、在Go语言中可以通过 `&+变量名` 获取到变量地址值

3、c:=&a

fmt.Printf("%T",c)    //输出*int

4、

- 使用`var 变量名 *类型` 声明指针类型变量
- 声明指针不会开辟内存地址,只是准备要指向内存某个空间,而声明变量会开辟内存地址,准备存放内容.所以指针类型变量都是把一个变量的地址赋值给指针变量



5、空指针

6、可以思考一下为什么输出是一样的

b:=123

a=&b

*a=456

fmt.Println(*a,b)     //输出456  456*

&b=789

fmt.Println(*a,b)		//输出789  789



# 一.变量地址

* 变量本质就是内存中一块数据的标记.把值存储到变量中实质是把值存储到内存中
* 每次对变量重新赋值就是在修改变量地址中的内容
* 在Go语言中可以通过 `&+变量名` 获取到变量地址值
* 重新创建一个非引用型变量(即使是把已有变量直接赋值给新变量)也会新开辟内存地址.
```go
func main() {
	a := 3
	fmt.Println(&a) //输出:地址
	a = 4
	fmt.Println(&a) //输出的地址不变

	b := a
	b = 5
	fmt.Println(&b, &a) //两个值不相同
	fmt.Println(b, a)   //输出:5 4
}
```

# 二.指针变量

* 指针变量指向一个值的内存地址
* 使用&+变量 返回值就是一个指针类型
* 使用`var 变量名 *类型` 声明指针类型变量
* 声明指针不会开辟内存地址,只是准备要指向内存某个空间,而声明变量会开辟内存地址,准备存放内容.所以指针类型变量都是把一个变量的地址赋值给指针变量
* 使用`*+指针`能够获取内存地址中的值.所以`*+指针`就和直接使用变量是相同的
* 应用指针可以实现多个地方操作同一个内存地址的值(在方法参数应用指针较多)
```go
func main() {
	//创建变量
	a := 123
	var point *int
	point = &a //此时point和&a是相等的
	fmt.Println(point)
	*point = 3             //等价于a=3
	fmt.Println(*point, a) //*point和a是相当的
}
```
# 三.空指针
* 指针目的就是指向内存中一块地址
* 声明指针后指针不会指向任何内存地址,所以此时指针是空.在Go语言中空用nil表示
```go
func main() {
	var a *int
	fmt.Println(a)        //输出:<nil>
	fmt.Println(a == nil) //输出true
}
```